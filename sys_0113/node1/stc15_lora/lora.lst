C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LORA
OBJECT MODULE PLACED IN .\OBJ\lora.obj
COMPILER INVOKED BY: D:\keil\KEIL_MDK\C51\BIN\C51.EXE APP\LoRa\lora.c LARGE ROM(COMPACT) OPTIMIZE(6,SIZE) BROWSE INCDIR(
                    -.\APP\base;.\APP\LoRa;.\APP\uart;.\APP\MidWare;.\APP\numTools;.\APP\sensor) DEBUG OBJECTEXTEND PRINT(.\lora.lst) OBJECT(
                    -.\OBJ\lora.obj)

line level    source

   1          #include "lora.h"
   2          #include "stdio.h"
   3          #include "gpio.h"
   4          #include "sx1278.h"
   5          #include "delay.h"
   6          #include "synchron.h"
   7          #include "sensor.h"
   8          
   9          extern u16 lastPeriod;
  10          extern u8 synReady;
  11          extern u16 currentNode;
  12          
  13          u8 nodeBrokenFlag = 0;
  14          unsigned char recv[20];
  15          u8 overTime = 0;
  16          unsigned char Frequency[23][3] = {      { 0x6C, 0x80, 0x00 },
  17                                                                                  { 0x67, 0x74, 0xDE },
  18                                                                                  { 0x68, 0xB7, 0xA6 },
  19                                                                                  { 0x6B, 0x3D, 0x37 },
  20                                                                                  { 0x6D, 0xC2, 0xC8 },
  21                                                                                  { 0x6F, 0x05, 0x90 },
  22                                                                                  { 0x70, 0x48, 0x59 },
  23                                                                                  { 0x71, 0x8B, 0x21 },
  24                                                                                  { 0x72, 0xCD, 0xE9 },
  25                                                                                  { 0x74, 0x10, 0xB2 },
  26                                                                                  { 0x75, 0x53, 0x7A },
  27                                                                                  { 0x76, 0x96, 0x42 },
  28                                                                                  { 0x77, 0xD9, 0x0B },
  29                                                                                  { 0x79, 0x1B, 0xD3 },
  30                                                                                  { 0x7A, 0x5E, 0x9B },
  31                                                                                  { 0x7B, 0xA1, 0x64 },
  32                                                                                  { 0x7C, 0xE4, 0x2C },
  33                                                                                  { 0x7E, 0x26, 0xF4 },
  34                                                                                  { 0x7F, 0x69, 0xBD },
  35                                                                                  { 0x80, 0xAC, 0x85 },
  36                                                                                  { 0x81, 0xEF, 0x4D },
  37                                                                                  { 0x83, 0x32, 0x16 }};
  38          
  39          void loraInit(void)
  40          {
  41   1              register_rf_func(&ctrlTypefunc);        //注册LoRa回调
  42   1              SX1276Reset();          //复位LoRa模块
  43   1              SX1276LORA_INT();
  44   1              
  45   1      //      SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);
  46   1      }
  47          
  48          void loraTx(u8 *dat, u8 len)
  49          {
  50   1              SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);
  51   1              FUN_RF_SENDPACKET(dat, len);
  52   1              Delay1s(500);
  53   1      //      SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);
C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 2   

  54   1      }
  55          
  56          //void loraTxByte(u8 dat)
  57          //{
  58          //      u8 array[10] = {0};
  59          //      
  60          //      SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);                                              //清空RxBuffer
  61          //      sprintf(array, "%d", dat);
  62          //      FUN_RF_SENDPACKET(array, 1);
  63          //}
  64          
  65          //void loraTxWord(u16 dat)
  66          //{
  67          //      u8 array[10] = {0};
  68          //      
  69          //      SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);                                              //清空RxBuffer
  70          //      sprintf(array, "%d", dat);
  71          //      FUN_RF_SENDPACKET(array, 2);
  72          //}
  73          
  74          //void loraTx8Byte(u8 *arr)
  75          //{
  76          ////    u8 array[10] = {0};
  77          //      
  78          //      SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);                                              //清空RxBuffer
  79          ////    sprintf(array, "%d", dat);
  80          //      FUN_RF_SENDPACKET(arr, 8);
  81          //}
  82          
  83          //void loraTxArray(u8 *arr, u8 len)
  84          //{
  85          //      while(len--)
  86          //      {
  87          //              loraTxByte(*arr);
  88          //              arr++;
  89          //      }
  90          //}
  91          
  92          
  93          void loraRxData(void)
  94          {
  95   1              unsigned char RF_REC_RLEN_i = 0;
  96   1              
  97   1              
  98   1              RF_EX0_STATUS = SX1276ReadBuffer( REG_LR_IRQFLAGS);
  99   1              if (RF_EX0_STATUS > 0) 
 100   1              {
 101   2                      if ((RF_EX0_STATUS & 0x40) == 0x40) 
 102   2                      {
 103   3                              LED1 = 0;
 104   3                              CRC_Value = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 105   3                              if (CRC_Value & 0x04 == 0x04)   //若开启了CRC
 106   3                              {
 107   4                                      SX1276WriteBuffer(REG_LR_FIFOADDRPTR, 0x00);
 108   4                                      SX1278_RLEN = SX1276ReadBuffer(REG_LR_NBRXBYTES);
 109   4                                      lpTypefunc.lpSwitchEnStatus(enOpen);
 110   4                                      lpTypefunc.lpByteWritefunc(0x00);
 111   4                                      
 112   4                                      for (RF_REC_RLEN_i = 0; RF_REC_RLEN_i < SX1278_RLEN;RF_REC_RLEN_i++) 
 113   4                                      {
 114   5                                              recv[RF_REC_RLEN_i] = lpTypefunc.lpByteReadfunc();
 115   5                                      }
C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 3   

 116   4                                      lpTypefunc.lpSwitchEnStatus(enClose);
 117   4                                      recv[RF_REC_RLEN_i] = '\0';
 118   4                                      synPeriod.byte[0] = recv[0];
 119   4                                      synPeriod.byte[1] = recv[1];
 120   4                                      RF_RECEIVE();                   
 121   4      //                              uartSendString(recv);                           //测试使用
 122   4                              }
 123   3                      } 
 124   2                      else if ((RF_EX0_STATUS & 0x04) == 0x04) 
 125   2                      {
 126   3                              if ((RF_EX0_STATUS & 0x01) == 0x01) //表示CAD 检测到扩频信号 模块进入了接收状态来接收数据
 127   3                              { 
 128   4                                      SX1276LoRaSetOpMode(Stdby_mode);
 129   4                                      SX1276WriteBuffer(REG_LR_IRQFLAGSMASK, IRQN_RXD_Value); //打开发送中断
 130   4                                      SX1276WriteBuffer(REG_LR_HOPPERIOD, PACKET_MIAX_Value);
 131   4                                      SX1276WriteBuffer( REG_LR_DIOMAPPING1, 0X02);
 132   4                                      SX1276WriteBuffer( REG_LR_DIOMAPPING2, 0x00);
 133   4                                      SX1276LoRaSetOpMode(Receiver_mode);
 134   4                              } 
 135   3                              else 
 136   3                              {                          
 137   4                                      SX1276LoRaSetOpMode(Stdby_mode);
 138   4                                      SX1276WriteBuffer(REG_LR_IRQFLAGSMASK,IRQN_SEELP_Value);   //打开发送中断
 139   4                                      SX1276WriteBuffer( REG_LR_DIOMAPPING1, 0X00);
 140   4                                      SX1276WriteBuffer( REG_LR_DIOMAPPING2, 0X00);
 141   4                                      SX1276LoRaSetOpMode(Sleep_mode);
 142   4                                      //PA_SEELP_OUT();
 143   4                              }
 144   3                      }
 145   2                      else 
 146   2                      {
 147   3                              SX1276LoRaSetOpMode(Stdby_mode);
 148   3                              SX1276WriteBuffer(REG_LR_IRQFLAGSMASK, IRQN_RXD_Value);  //打开发送中断
 149   3                              SX1276WriteBuffer(REG_LR_HOPPERIOD, PACKET_MIAX_Value);
 150   3                              SX1276WriteBuffer( REG_LR_DIOMAPPING1, 0x02);
 151   3                              SX1276WriteBuffer( REG_LR_DIOMAPPING2, 0x00);
 152   3                              SX1276LoRaSetOpMode(Receiver_mode);
 153   3                      }
 154   2                      RF_REC_RLEN_i = 0;
 155   2                      SX1276WriteBuffer( REG_LR_IRQFLAGS, 0xff);
 156   2                      //Delay1ms(300);
 157   2                      Delay100ms();
 158   2                      Delay100ms();
 159   2                      Delay100ms();
 160   2              }
 161   1              else
 162   1                      LED1 = 1;
 163   1      }
 164          
 165          
 166          #if(loraStationNum < 8)
              //对接新节点后，判断节点工作状态
              void loraNodeCheck(void)
              {
                      if(currentNode != (synPeriod /11*8 + loraStationNum))                   //若通信目标节点发生变化
                      {
                              if(recv[0] == nodeReadyFlag)    
                              {
                                      LED2 = 0;
                                      synReady = 1;                                                                                   //节点就绪标志位，LED2仅为测试阶段使用
                                      currentNode = synPeriod /11*8 + loraStationNum;                 //更新通信节点编号
                                      overTime = 0;                                                                                   //超时次数清空
C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 4   

                                      
                              }
                              else
                              {
                                      LED2 = 1;
                                      synReady = 0;
                                      overTime++;
                              }
                              
                              //若超时次数过多，或已经有两个周期没有收到就绪报文，则视为节点损坏
                              //这部分需要统一加入看门狗
              //              if(overTime > bokenThreshold || (synPeriod - lastPeriod) > 1)   
              //              {
              //                      nodeBrokenFlag = 1
              //              }
                      }
              }
              
              void loraNextPactet(void)
              {
                      u8 buffer[8] = {0};
                      
                      u8 crcCheck = 0;
                      if(lastPeriod != synPeriod)                             //若周期发生更新
                      {
                              buffer[0]='C'; buffer[1]='N';
                              loraTx(buffer, 2);
                              loraRxData();
                      }
                      
                      crcCheck = SX1276ReadBuffer(RegIrqFlags2);
                      if((crcCheck & 0x02) != 0x02)
                      {
                              buffer[0]='C'; buffer[1]='R';
                              loraTx(buffer, 2);
                              LED2 = 1;
                      }
                      
                      do
                      {
                              loraRxData();
                              crcCheck = SX1276ReadBuffer(RegIrqFlags2);
                              if((synPeriod - lastPeriod) > 1)
                              {
                                      lastPeriod = synPeriod;
                                      overTime++;
                                      return;
                              }
                              
                              if(KEY0 == 0)
                                      break;                  //测试用
                              
                      }while((crcCheck & 0x02) != 0x02);              //若CRC校验失败
                      
                      loraNodeFreqHopping();
                      lastPeriod = synPeriod;
                      LED2 = 0;
              }
              
              
              void loraNodeFreqHopping(void)
              {
C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 5   

                      if(synPeriod % (packetLength + 1) == packetLength)
                      {
                              loraTxByte('J');
                      }
              }
              
              #endif
 247          
 248          
 249          #if(loraStationNum == 99)
              void loraCommunicateStart(void)
              {
                      loraTxByte(0xDD);
                      Delay1ms(50);
                      loraTxByte(0xDD);
                      Delay1ms(50);
              }
              
              
              void loraNodeSleep(void)
              {
                      loraTxByte('S');
                      Delay1ms(50);
                      loraTxByte('S');
                      Delay1ms(50);
              }
              
              //u16 loraCycle(u16 period)
              //{
              //      
              //}
              
              #endif
 273          
 274          
 275          #ifdef loraNodeNum
 276          
 277          extern u8 Freq[3];
 278          void loraFreqHopping(void)
 279          {
 280   1              do
 281   1              {
 282   2                      loraRxData();
 283   2      //              Delay100ms();
 284   2              }while(synPeriod.word != (loraNodeNum/8));      //当周期轮到自己通信时
 285   1              
 286   1              if(synPeriod.word % 2 == 0)             //判断是奇数组还是偶数组
 287   1              {
 288   2                      Freq[0] = Frequency[loraNodeNum % 8+1][0];              //0号频段给独立电台长期占用了
 289   2                      Freq[1] = Frequency[loraNodeNum % 8+1][1];
 290   2                      Freq[2] = Frequency[loraNodeNum % 8+1][2];
 291   2              }
 292   1              else
 293   1              {
 294   2                      Freq[0] = Frequency[loraNodeNum % 8+9][0];
 295   2                      Freq[1] = Frequency[loraNodeNum % 8+9][1];
 296   2                      Freq[2] = Frequency[loraNodeNum % 8+9][2];
 297   2              }
 298   1              
 299   1      //              Freq[0] = 0x68;
 300   1      //              Freq[1] = 0xB7;
 301   1      //              Freq[2] = 0xA6;
C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 6   

 302   1              loraInit();
 303   1      }
 304          
 305          
 306          void loraFreqDisHopping(void)
 307          {
 308   1              Freq[0] = 0x6c;
 309   1              Freq[1] = 0x80;
 310   1              Freq[2] = 0x00;
 311   1              loraInit();
 312   1      }
 313          
 314          
 315          void loraNodeAck(void)
 316          {
 317   1              u8 buffer[8] = {0};
 318   1              
 319   1              buffer[0]=nodeReadyFlag;
 320   1              loraTx(buffer, 1);
 321   1              while(1)
 322   1              {
 323   2                      loraRxData();
 324   2                      if(recv[0] ==  'C' && recv[1] !=  'N')
 325   2                      {
 326   3                              buffer[0]=nodeReadyFlag;
 327   3                              loraTx(buffer, 1);
 328   3                      }
 329   2                      else
 330   2                              break;
 331   2                      
 332   2                      if(recv[0] ==  'C' && (recv[1] ==  'R' || recv[1] ==  'J'))
 333   2                              break;          //预防措施
 334   2                      Delay1ms(10);
 335   2              }
 336   1      }
 337          
 338          extern sensorStruct sensorData;
 339          void loraNodeCommunicate(void)
 340          {
 341   1              u8 i=0;
 342   1      //      word2byte tx_buff[4];
 343   1              u8 tx_buff[8];
 344   1              u16 lastDataNum = 0;
 345   1              
 346   1              getAllData(&sensorData);
 347   1      //      tx_buff[0] = (u8)(sensorData.wet >> 8);
 348   1      //      tx_buff[1] = (u8)(sensorData.wet);
 349   1      //      tx_buff[2] = (u8)(sensorData.temperature >> 8);
 350   1      //      tx_buff[3] = (u8)(sensorData.temperature);
 351   1      //      tx_buff[4] = sensorData.power;
 352   1      //      tx_buff[5] = sensorData.swi;
 353   1      //      tx_buff[6] = 0;
 354   1      //      tx_buff[7] = 0;
 355   1              tx_buff[0] = 0x12;
 356   1              tx_buff[1] = 0x23;
 357   1              tx_buff[2] = 0x34;
 358   1              tx_buff[3] = 0x45;
 359   1              tx_buff[4] = 0x56;
 360   1              tx_buff[5] = 0x67;
 361   1              tx_buff[6] = 0x78;
 362   1              tx_buff[7] = 0x89;
 363   1              
C51 COMPILER V9.60.0.0   LORA                                                              01/13/2024 20:02:56 PAGE 7   

 364   1              for(i=0; i<5; i++)//
 365   1              {
 366   2                      loraTx(tx_buff, 8);
 367   2                      lastDataNum++;
 368   2                      Delay100ms();Delay100ms();//Delay300ms();                               //太高的发送频率会导致射频部分发热严重，且通信质量差
 369   2                      if(KEY1 == 0)
 370   2                      {
 371   3                              break;
 372   3                      }
 373   2              }
 374   1      }
 375          
 376          #endif
 377          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    713    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =     91      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   SX1278                                                            01/13/2024 20:02:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SX1278
OBJECT MODULE PLACED IN .\OBJ\sx1278.obj
COMPILER INVOKED BY: D:\keil\KEIL_MDK\C51\BIN\C51.EXE APP\LoRa\sx1278.c LARGE ROM(COMPACT) OPTIMIZE(6,SIZE) BROWSE INCDI
                    -R(.\APP\base;.\APP\LoRa;.\APP\uart;.\APP\MidWare;.\APP\numTools;.\APP\sensor) DEBUG OBJECTEXTEND PRINT(.\sx1278.lst) OBJ
                    -ECT(.\OBJ\sx1278.obj)

line level    source

   1          
   2          /******************************************************************************/
   3          /*                        --安信可科技有限公司--                        */
   4          /*
   5          //  函数说明：main.c                                                              
   6          //  说明：该程序用于测试lora模块                                                              
             -  
   7          //  编写人员： sky                                                                 
   8          // 编写日期： 2016-11-24                                                         
   9          // 版本号:V1.0
  10          // 维护日志：
  11          //
  12          //                                                          
  13          */ 
  14          // 免责声明：该程序仅供参考学习，若自定义其他功能，请查看参考手册
  15          // (c) Anxinke Corporation. All rights reserved.                                                          
             -     
  16          /******************************************************************************/
  17          #include "sx1278.h"
  18          #include "delay.h"
  19          
  20          //#include "reg51.hcd"
  21          lpCtrlTypefunc_t lpTypefunc = { 0, 0, 0 };
  22          unsigned char power_data[8] = { 0X80, 0X80, 0X80, 0X83, 0X86, 0x89, 0x8c, 0x8f };
  23          
  24          lpCtrlTypefunc_t ctrlTypefunc =
  25                          { 
  26                                  RF_SPI_MasterIO, RF_SPI_READ_BYTE, cmdSwitchEn,
  27                          };
  28          
  29          unsigned char Freq[3] = { 0x6C, 0x80, 0x00 };   //434000000 
  30          
  31          unsigned char powerValue = 7;
  32          unsigned char SpreadingFactor = 12;    //扩频因子7-12
  33          
  34          
  35          //unsigned char CodingRate = 2;        //1-4
  36          unsigned char CodingRate = 1;        //1-4
  37          
  38          
  39          unsigned char Bw_Frequency = 7;      //带宽6-9,7--125K
  40          unsigned char RF_EX0_STATUS;
  41          unsigned char CRC_Value;
  42          unsigned char SX1278_RLEN;
  43          //unsigned char recv[512];
  44          
  45          
  46          //void Delay1s(unsigned int ii)
  47          //{
  48          //  int j;
  49          //   while(ii--){
  50          //     for(j=0;j<1000;j++);
  51          //   }
C51 COMPILER V9.60.0.0   SX1278                                                            01/13/2024 20:02:55 PAGE 2   

  52          //}
  53          
  54          /*
  55          function:SX1278 restart
  56          */
  57          
  58          void  SX1276Reset(void) {
  59   1              RF_REST_L;
  60   1              Delay1s(200);
  61   1              RF_REST_H;
  62   1              Delay1s(500);
  63   1      }
  64          
  65          
  66          /*
  67          function:control GPIO-EN
  68          */
  69          void  cmdSwitchEn(cmdEntype_t cmd) {
  70   1              switch (cmd) {
  71   2              case enOpen: {
  72   3                      RF_CE_L;
  73   3              }
  74   2                      break;
  75   2              case enClose: {
  76   3                      RF_CE_H;
  77   3              }
  78   2                      break;
  79   2              default:
  80   2                      break;
  81   2              }
  82   1      }
  83          
  84          
  85          
  86          
  87          void  RF_SPI_MasterIO(unsigned char out) {
  88   1              unsigned char i;
  89   1              for (i = 0; i < 8; i++) {
  90   2                      if (out & 0x80) /* check if MSB is high */
  91   2                              RF_SDI_H;
  92   2                      else
  93   2                              RF_SDI_L; /* if not, set to low */
  94   2      
  95   2                      RF_CKL_H; /* toggle clock high */
  96   2                      out = (out << 1); /* shift 1 place for next bit */
  97   2                      RF_CKL_L; /* toggle clock low */
  98   2              }
  99   1      }
 100          
 101          unsigned char   RF_SPI_READ_BYTE() {
 102   1              unsigned char j;
 103   1              unsigned char i;
 104   1              j = 0;
 105   1              for (i = 0; i < 8; i++) {
 106   2                      RF_CKL_H;
 107   2                      j = (j << 1);                   // shift 1 place to the left or shift in 0 //
 108   2                      if ( SX1278_SDO)                                        // check to see if bit is high //
 109   2                              j = j | 0x01;                                      // if high, make bit high //
 110   2                                                                                                 // toggle clock high //
 111   2                      RF_CKL_L;                                                        // toggle clock low //
 112   2              }
 113   1      
C51 COMPILER V9.60.0.0   SX1278                                                            01/13/2024 20:02:55 PAGE 3   

 114   1              return j;                                                               // toggle clock low //
 115   1      }
 116          unsigned char  SX1276ReadBuffer(unsigned char addr) {
 117   1              unsigned char Value;
 118   1              lpTypefunc.lpSwitchEnStatus(enOpen); //NSS = 0;
 119   1              lpTypefunc.lpByteWritefunc(addr & 0x7f);
 120   1              Value = lpTypefunc.lpByteReadfunc();
 121   1              lpTypefunc.lpSwitchEnStatus(enClose); //NSS = 1;
 122   1      
 123   1              return Value;
 124   1      }
 125          
 126          /*
 127          function:set sx1278 work mode ,here you can control the mode which is send or recieve 
 128          parm: 
 129          */
 130          void  SX1276LoRaSetOpMode(RFMode_SET opMode) {
 131   1              unsigned char opModePrev;
 132   1              opModePrev = SX1276ReadBuffer(REG_LR_OPMODE);
 133   1              opModePrev &= 0xf8;
 134   1              opModePrev |= (unsigned char) opMode;
 135   1              SX1276WriteBuffer( REG_LR_OPMODE, opModePrev);
 136   1      }
 137          
 138          
 139          
 140          void  SX1276WriteBuffer(unsigned char addr,
 141                          unsigned char buffer) {
 142   1              lpTypefunc.lpSwitchEnStatus(enOpen); //NSS = 0;
 143   1              lpTypefunc.lpByteWritefunc(addr | 0x80);
 144   1              lpTypefunc.lpByteWritefunc(buffer);
 145   1              lpTypefunc.lpSwitchEnStatus(enClose); //NSS = 1;
 146   1      }
 147          
 148          void  register_rf_func(lpCtrlTypefunc_t *func) {
 149   1              if (func->lpByteWritefunc != 0) {
 150   2                      lpTypefunc.lpByteWritefunc = func->lpByteWritefunc;
 151   2              }
 152   1              if (func->lpByteReadfunc != 0) {
 153   2                      lpTypefunc.lpByteReadfunc = func->lpByteReadfunc;
 154   2              }
 155   1              if (func->lpSwitchEnStatus != 0) {
 156   2                      lpTypefunc.lpSwitchEnStatus = func->lpSwitchEnStatus;
 157   2              }
 158   1      
 159   1      }
 160          
 161          void  SX1276LoRaSetRFFrequency(void) {
 162   1              SX1276WriteBuffer( REG_LR_FRFMSB, Freq[0]);//0x04射频载波频率最高有效位
 163   1              SX1276WriteBuffer( REG_LR_FRFMID, Freq[1]);//0x07射频载波频率中间有效位
 164   1              SX1276WriteBuffer( REG_LR_FRFLSB, Freq[2]);//0x00射频载波频率最低有效位
 165   1      }
 166          
 167          void  SX1276LoRaSetNbTrigPeaks(unsigned char value) {
 168   1              unsigned char RECVER_DAT;
 169   1              RECVER_DAT = SX1276ReadBuffer(0x31);
 170   1              RECVER_DAT = (RECVER_DAT & 0xF8) | value;
 171   1              SX1276WriteBuffer(0x31, RECVER_DAT);
 172   1      }
 173          
 174          void  SX1276LoRaSetSpreadingFactor(unsigned char factor) {
 175   1              unsigned char RECVER_DAT;
C51 COMPILER V9.60.0.0   SX1278                                                            01/13/2024 20:02:55 PAGE 4   

 176   1              SX1276LoRaSetNbTrigPeaks(3);
 177   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 178   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG2_SF_MASK) | (factor << 4);
 179   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG2, RECVER_DAT);
 180   1      }
 181          
 182          void  SX1276LoRaSetErrorCoding(unsigned char value) {
 183   1              unsigned char RECVER_DAT;
 184   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG1);
 185   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG1_CODINGRATE_MASK)
 186   1                              | (value << 1);
 187   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG1, RECVER_DAT);
 188   1      // LoRaSettings.ErrorCoding = value;
 189   1      }
 190          
 191          void  SX1276LoRaSetSignalBandwidth(unsigned char bw) {
 192   1              unsigned char RECVER_DAT;
 193   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG1);
 194   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG1_BW_MASK) | (bw << 4);
 195   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG1, RECVER_DAT);
 196   1      // LoRaSettings.SignalBw = bw;
 197   1      }
 198          
 199          void  SX1276LoRaSetImplicitHeaderOn(BOOL enable) {
 200   1              unsigned char RECVER_DAT;
 201   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG1);
 202   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK)
 203   1                              | (enable);
 204   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG1, RECVER_DAT);
 205   1      }
 206          
 207          void  SX1276LoRaSetPayloadLength(unsigned char value) {
 208   1              SX1276WriteBuffer( REG_LR_PAYLOADLENGTH, value);
 209   1      }
 210          
 211          void  SX1276LoRaSetSymbTimeout(unsigned int value) {
 212   1              unsigned char RECVER_DAT[2];
 213   1              RECVER_DAT[0] = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 214   1              RECVER_DAT[1] = SX1276ReadBuffer( REG_LR_SYMBTIMEOUTLSB);
 215   1              RECVER_DAT[0] = (RECVER_DAT[0] & RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK)
 216   1                              | ((value >> 8) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK);
 217   1              RECVER_DAT[1] = value & 0xFF;
 218   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG2, RECVER_DAT[0]);
 219   1              SX1276WriteBuffer( REG_LR_SYMBTIMEOUTLSB, RECVER_DAT[1]);
 220   1      }
 221          
 222          void  SX1276LoRaSetMobileNode(BOOL enable) {
 223   1              unsigned char RECVER_DAT;
 224   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG3);
 225   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG3_MOBILE_NODE_MASK)
 226   1                              | (enable << 3);
 227   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG3, RECVER_DAT);
 228   1      }
 229          
 230          void  RF_RECEIVE(void) {
 231   1              SX1276LoRaSetOpMode(Stdby_mode);
 232   1              SX1276WriteBuffer(REG_LR_IRQFLAGSMASK, IRQN_RXD_Value);  //打开发送中断
 233   1              SX1276WriteBuffer(REG_LR_HOPPERIOD, PACKET_MIAX_Value);
 234   1              SX1276WriteBuffer( REG_LR_DIOMAPPING1, 0X00);
 235   1              SX1276WriteBuffer( REG_LR_DIOMAPPING2, 0X00);
 236   1              SX1276LoRaSetOpMode(Receiver_mode);
 237   1      //   lpTypefunc.paSwitchCmdfunc(rxOpen);
C51 COMPILER V9.60.0.0   SX1278                                                            01/13/2024 20:02:55 PAGE 5   

 238   1      }
 239          
 240          void  SX1276LoRaSetPacketCrcOn(BOOL enable) {
 241   1              unsigned char RECVER_DAT;
 242   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 243   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK)
 244   1                              | (enable << 2);
 245   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG2, RECVER_DAT);
 246   1      }
 247          
 248          void  SX1276LoRaFsk(Debugging_fsk_ook opMode) {
 249   1              unsigned char opModePrev;
 250   1              opModePrev = SX1276ReadBuffer(REG_LR_OPMODE);
 251   1              opModePrev &= 0x7F;
 252   1              opModePrev |= (unsigned char) opMode;
 253   1              SX1276WriteBuffer( REG_LR_OPMODE, opModePrev);
 254   1      }
 255          
 256          
 257          void  SX1276LoRaSetRFPower(unsigned char power) {
 258   1              SX1276WriteBuffer( REG_LR_PADAC, 0x87);
 259   1              SX1276WriteBuffer( REG_LR_PACONFIG, power_data[power]);
 260   1      }
 261          
 262          
 263          /*
 264          function :you must call it ,the function is to init the module.
 265          */
 266          void  SX1276LORA_INT(void) {
 267   1              SX1276LoRaSetOpMode(Sleep_mode);  //设置睡眠模式0x01
 268   1              SX1276LoRaFsk(LORA_mode);             // 设置扩频模式,只能在睡眠模式下修改
 269   1              SX1276LoRaSetOpMode(Stdby_mode);   // 设置为普通模式
 270   1              SX1276WriteBuffer( REG_LR_DIOMAPPING1, GPIO_VARE_1);
 271   1              SX1276WriteBuffer( REG_LR_DIOMAPPING1, GPIO_VARE_1);
 272   1              SX1276WriteBuffer( REG_LR_DIOMAPPING2, GPIO_VARE_2);
 273   1              SX1276LoRaSetRFFrequency();
 274   1              SX1276LoRaSetRFPower(powerValue);
 275   1              SX1276LoRaSetSpreadingFactor(SpreadingFactor);   // 扩频因子设置
 276   1              SX1276LoRaSetErrorCoding(CodingRate);            //有效数据比
 277   1              SX1276LoRaSetPacketCrcOn(true);                   //CRC 校验打开
 278   1              SX1276LoRaSetSignalBandwidth(Bw_Frequency);      //设置扩频带宽
 279   1              SX1276LoRaSetImplicitHeaderOn(false);           //同步头是显性模式
 280   1              SX1276LoRaSetPayloadLength(0xff);//0x22 timeout中断
 281   1              SX1276LoRaSetSymbTimeout(0x3FF);
 282   1              SX1276LoRaSetMobileNode(true);                   // 低数据的优化
 283   1              RF_RECEIVE();
 284   1              uartSendString("\r\ninit finish\r\n");
 285   1      
 286   1      }
 287          
 288          /*
 289          function :if you want to send data,you can call it 
 290          RF_TRAN_P:data
 291          ASM_i:the length of the data
 292          */
 293          void  FUN_RF_SENDPACKET(unsigned char *RF_TRAN_P,
 294                          unsigned char LEN) {
 295   1              unsigned char ASM_i;
 296   1      //   lpTypefunc.paSwitchCmdfunc(txOpen);
 297   1              SX1276LoRaSetOpMode(Stdby_mode);
 298   1              SX1276WriteBuffer( REG_LR_HOPPERIOD, 0);        //不做频率跳变
 299   1              SX1276WriteBuffer(REG_LR_IRQFLAGSMASK, IRQN_TXD_Value); //打开发送中断
C51 COMPILER V9.60.0.0   SX1278                                                            01/13/2024 20:02:55 PAGE 6   

 300   1              SX1276WriteBuffer( REG_LR_PAYLOADLENGTH, LEN);   //最大数据包
 301   1              SX1276WriteBuffer( REG_LR_FIFOTXBASEADDR, 0);
 302   1              SX1276WriteBuffer( REG_LR_FIFOADDRPTR, 0);
 303   1              lpTypefunc.lpSwitchEnStatus(enOpen);
 304   1              lpTypefunc.lpByteWritefunc(0x80);
 305   1              for (ASM_i = 0; ASM_i < LEN; ASM_i++) {
 306   2                      lpTypefunc.lpByteWritefunc(*RF_TRAN_P);
 307   2                      RF_TRAN_P++;
 308   2              }
 309   1              lpTypefunc.lpSwitchEnStatus(enClose);
 310   1              SX1276WriteBuffer(REG_LR_DIOMAPPING1, 0x40);
 311   1              SX1276WriteBuffer(REG_LR_DIOMAPPING2, 0x00);
 312   1              SX1276LoRaSetOpMode(Transmitter_mode);
 313   1      }
 314          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1057    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     36      26
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

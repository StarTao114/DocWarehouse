C51 COMPILER V9.60.0.0   SX1278                                                            01/12/2024 22:11:18 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SX1278
OBJECT MODULE PLACED IN .\OBJ\sx1278.obj
COMPILER INVOKED BY: D:\keil\KEIL_MDK\C51\BIN\C51.EXE APP\LoRa\sx1278.c LARGE ROM(COMPACT) OPTIMIZE(0,SPEED) BROWSE INCD
                    -IR(.\APP\base;.\APP\LoRa;.\APP\uart;.\APP\MidWare;.\APP\numTools) DEBUG OBJECTEXTEND PRINT(.\sx1278.lst) OBJECT(.\OBJ\sx
                    -1278.obj)

line level    source

   1          
   2          /******************************************************************************/
   3          /*                        --安信可科技有限公司--                        */
   4          /*
   5          //  函数说明：main.c                                                              
   6          //  说明：该程序用于测试lora模块                                                              
             -  
   7          //  编写人员： sky                                                                 
   8          // 编写日期： 2016-11-24                                                         
   9          // 版本号:V1.0
  10          // 维护日志：
  11          //
  12          //                                                          
  13          */ 
  14          // 免责声明：该程序仅供参考学习，若自定义其他功能，请查看参考手册
  15          // (c) Anxinke Corporation. All rights reserved.                                                          
             -     
  16          /******************************************************************************/
  17          #include "sx1278.h"
  18          
  19          //#include "reg51.hcd"
  20          lpCtrlTypefunc_t lpTypefunc = { 0, 0, 0 };
  21          unsigned char power_data[8] = { 0X80, 0X80, 0X80, 0X83, 0X86, 0x89, 0x8c, 0x8f };
  22          
  23          lpCtrlTypefunc_t ctrlTypefunc =
  24                          { RF_SPI_MasterIO, RF_SPI_READ_BYTE, cmdSwitchEn,
  25          
  26                          };
  27          
  28          /**
  29          * @brief        新版分频方案，以434MHz为基准，频间距5.04MHz，频宽100Hz
  30          * @date         01/10/24
  31          */
  32          //unsigned char Frequency[3] = { 0x67, 0x74, 0xDE };    //413826088             单位：Hz
  33          //unsigned char Frequency[3] = { 0x68, 0xB7, 0xA6 };    //418869566 
  34          //unsigned char Frequency[3] = { 0x69, 0xFA, 0x6F };    //423913044 
  35          //unsigned char Frequency[3] = { 0x6B, 0x3D, 0x37 };    //428956522 
  36          unsigned char Frequency[3] = { 0x6C, 0x80, 0x00 };      //434000000 
  37          //unsigned char Frequency[3] = { 0x6D, 0xC2, 0xC8 };    //439043478 
  38          //unsigned char Frequency[3] = { 0x6F, 0x05, 0x90 };    //444086956 
  39          //unsigned char Frequency[3] = { 0x70, 0x48, 0x59 };    //449130434 
  40          //unsigned char Frequency[3] = { 0x71, 0x8B, 0x21 };    //454173912 
  41          //unsigned char Frequency[3] = { 0x72, 0xCD, 0xE9 };    //459217390 
  42          //unsigned char Frequency[3] = { 0x74, 0x10, 0xB2 };    //464260868 
  43          //unsigned char Frequency[3] = { 0x75, 0x53, 0x7A };    //469304346 
  44          //unsigned char Frequency[3] = { 0x76, 0x96, 0x42 };    //474347824 
  45          //unsigned char Frequency[3] = { 0x77, 0xD9, 0x0B };    //479391302 
  46          //unsigned char Frequency[3] = { 0x79, 0x1B, 0xD3 };    //484434780 
  47          //unsigned char Frequency[3] = { 0x7A, 0x5E, 0x9B };    //489478258 
  48          //unsigned char Frequency[3] = { 0x7B, 0xA1, 0x64 };    //494521736 
  49          //unsigned char Frequency[3] = { 0x7C, 0xE4, 0x2C };    //499565214 
  50          //unsigned char Frequency[3] = { 0x7E, 0x26, 0xF4 };    //504608692 
  51          //unsigned char Frequency[3] = { 0x7F, 0x69, 0xBD };    //509652170 
C51 COMPILER V9.60.0.0   SX1278                                                            01/12/2024 22:11:18 PAGE 2   

  52          //unsigned char Frequency[3] = { 0x80, 0xAC, 0x85 };    //514695648 
  53          //unsigned char Frequency[3] = { 0x81, 0xEF, 0x4D };    //519739126 
  54          //unsigned char Frequency[3] = { 0x83, 0x32, 0x16 };    //524782604 
  55          
  56          
  57          
  58          unsigned char powerValue = 7;
  59          unsigned char SpreadingFactor = 12;    //扩频因子7-12
  60          
  61          
  62          //unsigned char CodingRate = 2;        //1-4
  63          unsigned char CodingRate = 1;        //1-4
  64          
  65          
  66          unsigned char Bw_Frequency = 7;      //带宽6-9,7--125K
  67          unsigned char RF_EX0_STATUS;
  68          unsigned char CRC_Value;
  69          unsigned char SX1278_RLEN;
  70          //unsigned char recv[512];
  71          
  72          
  73          void Delay1s(unsigned int ii)
  74          {
  75   1        int j;
  76   1         while(ii--){
  77   2           for(j=0;j<1000;j++);
  78   2         }
  79   1      }
  80          
  81          /*
  82          function:SX1278 restart
  83          */
  84          
  85          void  SX1276Reset(void) {
  86   1              RF_REST_L;
  87   1              Delay1s(200);
  88   1              RF_REST_H;
  89   1              Delay1s(500);
  90   1      }
  91          
  92          
  93          /*
  94          function:control GPIO-EN
  95          */
  96          void  cmdSwitchEn(cmdEntype_t cmd) {
  97   1              switch (cmd) {
  98   2              case enOpen: {
  99   3                      RF_CE_L;
 100   3              }
 101   2                      break;
 102   2              case enClose: {
 103   3                      RF_CE_H;
 104   3              }
 105   2                      break;
 106   2              default:
 107   2                      break;
 108   2              }
 109   1      }
 110          
 111          
 112          
 113          
C51 COMPILER V9.60.0.0   SX1278                                                            01/12/2024 22:11:18 PAGE 3   

 114          void  RF_SPI_MasterIO(unsigned char out) {
 115   1              unsigned char i;
 116   1              for (i = 0; i < 8; i++) {
 117   2                      if (out & 0x80) /* check if MSB is high */
 118   2                              RF_SDI_H;
 119   2                      else
 120   2                              RF_SDI_L; /* if not, set to low */
 121   2      
 122   2                      RF_CKL_H; /* toggle clock high */
 123   2                      out = (out << 1); /* shift 1 place for next bit */
 124   2                      RF_CKL_L; /* toggle clock low */
 125   2              }
 126   1      }
 127          
 128          unsigned char   RF_SPI_READ_BYTE() {
 129   1              unsigned char j;
 130   1              unsigned char i;
 131   1              j = 0;
 132   1              for (i = 0; i < 8; i++) {
 133   2                      RF_CKL_H;
 134   2                      j = (j << 1);                   // shift 1 place to the left or shift in 0 //
 135   2                      if ( SX1278_SDO)                                        // check to see if bit is high //
 136   2                              j = j | 0x01;                                      // if high, make bit high //
 137   2                                                                                                 // toggle clock high //
 138   2                      RF_CKL_L;                                                        // toggle clock low //
 139   2              }
 140   1      
 141   1              return j;                                                               // toggle clock low //
 142   1      }
 143          unsigned char  SX1276ReadBuffer(unsigned char addr) {
 144   1              unsigned char Value;
 145   1              lpTypefunc.lpSwitchEnStatus(enOpen); //NSS = 0;
 146   1              lpTypefunc.lpByteWritefunc(addr & 0x7f);
 147   1              Value = lpTypefunc.lpByteReadfunc();
 148   1              lpTypefunc.lpSwitchEnStatus(enClose); //NSS = 1;
 149   1      
 150   1              return Value;
 151   1      }
 152          
 153          /*
 154          function:set sx1278 work mode ,here you can control the mode which is send or recieve 
 155          parm: 
 156          */
 157          void  SX1276LoRaSetOpMode(RFMode_SET opMode) {
 158   1              unsigned char opModePrev;
 159   1              opModePrev = SX1276ReadBuffer(REG_LR_OPMODE);
 160   1              opModePrev &= 0xf8;
 161   1              opModePrev |= (unsigned char) opMode;
 162   1              SX1276WriteBuffer( REG_LR_OPMODE, opModePrev);
 163   1      }
 164          
 165          
 166          
 167          void  SX1276WriteBuffer(unsigned char addr,
 168                          unsigned char buffer) {
 169   1              lpTypefunc.lpSwitchEnStatus(enOpen); //NSS = 0;
 170   1              lpTypefunc.lpByteWritefunc(addr | 0x80);
 171   1              lpTypefunc.lpByteWritefunc(buffer);
 172   1              lpTypefunc.lpSwitchEnStatus(enClose); //NSS = 1;
 173   1      }
 174          
 175          void  register_rf_func(lpCtrlTypefunc_t *func) {
C51 COMPILER V9.60.0.0   SX1278                                                            01/12/2024 22:11:18 PAGE 4   

 176   1              if (func->lpByteWritefunc != 0) {
 177   2                      lpTypefunc.lpByteWritefunc = func->lpByteWritefunc;
 178   2              }
 179   1              if (func->lpByteReadfunc != 0) {
 180   2                      lpTypefunc.lpByteReadfunc = func->lpByteReadfunc;
 181   2              }
 182   1              if (func->lpSwitchEnStatus != 0) {
 183   2                      lpTypefunc.lpSwitchEnStatus = func->lpSwitchEnStatus;
 184   2              }
 185   1      
 186   1      }
 187          
 188          void  SX1276LoRaSetRFFrequency(void) {
 189   1              SX1276WriteBuffer( REG_LR_FRFMSB, Frequency[0]);//0x04射频载波频率最高有效位
 190   1              SX1276WriteBuffer( REG_LR_FRFMID, Frequency[1]);//0x07射频载波频率中间有效位
 191   1              SX1276WriteBuffer( REG_LR_FRFLSB, Frequency[2]);//0x00射频载波频率最低有效位
 192   1      }
 193          
 194          void  SX1276LoRaSetNbTrigPeaks(unsigned char value) {
 195   1              unsigned char RECVER_DAT;
 196   1              RECVER_DAT = SX1276ReadBuffer(0x31);
 197   1              RECVER_DAT = (RECVER_DAT & 0xF8) | value;
 198   1              SX1276WriteBuffer(0x31, RECVER_DAT);
 199   1      }
 200          
 201          void  SX1276LoRaSetSpreadingFactor(unsigned char factor) {
 202   1              unsigned char RECVER_DAT;
 203   1              SX1276LoRaSetNbTrigPeaks(3);
 204   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 205   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG2_SF_MASK) | (factor << 4);
 206   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG2, RECVER_DAT);
 207   1      }
 208          
 209          void  SX1276LoRaSetErrorCoding(unsigned char value) {
 210   1              unsigned char RECVER_DAT;
 211   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG1);
 212   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG1_CODINGRATE_MASK)
 213   1                              | (value << 1);
 214   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG1, RECVER_DAT);
 215   1      // LoRaSettings.ErrorCoding = value;
 216   1      }
 217          
 218          void  SX1276LoRaSetSignalBandwidth(unsigned char bw) {
 219   1              unsigned char RECVER_DAT;
 220   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG1);
 221   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG1_BW_MASK) | (bw << 4);
 222   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG1, RECVER_DAT);
 223   1      // LoRaSettings.SignalBw = bw;
 224   1      }
 225          
 226          void  SX1276LoRaSetImplicitHeaderOn(BOOL enable) {
 227   1              unsigned char RECVER_DAT;
 228   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG1);
 229   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK)
 230   1                              | (enable);
 231   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG1, RECVER_DAT);
 232   1      }
 233          
 234          void  SX1276LoRaSetPayloadLength(unsigned char value) {
 235   1              SX1276WriteBuffer( REG_LR_PAYLOADLENGTH, value);
 236   1      }
 237          
C51 COMPILER V9.60.0.0   SX1278                                                            01/12/2024 22:11:18 PAGE 5   

 238          void  SX1276LoRaSetSymbTimeout(unsigned int value) {
 239   1              unsigned char RECVER_DAT[2];
 240   1              RECVER_DAT[0] = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 241   1              RECVER_DAT[1] = SX1276ReadBuffer( REG_LR_SYMBTIMEOUTLSB);
 242   1              RECVER_DAT[0] = (RECVER_DAT[0] & RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK)
 243   1                              | ((value >> 8) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK);
 244   1              RECVER_DAT[1] = value & 0xFF;
 245   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG2, RECVER_DAT[0]);
 246   1              SX1276WriteBuffer( REG_LR_SYMBTIMEOUTLSB, RECVER_DAT[1]);
 247   1      }
 248          
 249          void  SX1276LoRaSetMobileNode(BOOL enable) {
 250   1              unsigned char RECVER_DAT;
 251   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG3);
 252   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG3_MOBILE_NODE_MASK)
 253   1                              | (enable << 3);
 254   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG3, RECVER_DAT);
 255   1      }
 256          
 257          void  RF_RECEIVE(void) {
 258   1              SX1276LoRaSetOpMode(Stdby_mode);
 259   1              SX1276WriteBuffer(REG_LR_IRQFLAGSMASK, IRQN_RXD_Value);  //打开发送中断
 260   1              SX1276WriteBuffer(REG_LR_HOPPERIOD, PACKET_MIAX_Value);
 261   1              SX1276WriteBuffer( REG_LR_DIOMAPPING1, 0X00);
 262   1              SX1276WriteBuffer( REG_LR_DIOMAPPING2, 0X00);
 263   1              SX1276LoRaSetOpMode(Receiver_mode);
 264   1      //   lpTypefunc.paSwitchCmdfunc(rxOpen);
 265   1      }
 266          
 267          void  SX1276LoRaSetPacketCrcOn(BOOL enable) {
 268   1              unsigned char RECVER_DAT;
 269   1              RECVER_DAT = SX1276ReadBuffer( REG_LR_MODEMCONFIG2);
 270   1              RECVER_DAT = (RECVER_DAT & RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK)
 271   1                              | (enable << 2);
 272   1              SX1276WriteBuffer( REG_LR_MODEMCONFIG2, RECVER_DAT);
 273   1      }
 274          
 275          void  SX1276LoRaFsk(Debugging_fsk_ook opMode) {
 276   1              unsigned char opModePrev;
 277   1              opModePrev = SX1276ReadBuffer(REG_LR_OPMODE);
 278   1              opModePrev &= 0x7F;
 279   1              opModePrev |= (unsigned char) opMode;
 280   1              SX1276WriteBuffer( REG_LR_OPMODE, opModePrev);
 281   1      }
 282          
 283          
 284          void  SX1276LoRaSetRFPower(unsigned char power) {
 285   1              SX1276WriteBuffer( REG_LR_PADAC, 0x87);
 286   1              SX1276WriteBuffer( REG_LR_PACONFIG, power_data[power]);
 287   1      }
 288          
 289          
 290          /*
 291          function :you must call it ,the function is to init the module.
 292          */
 293          void  SX1276LORA_INT(void) {
 294   1              SX1276LoRaSetOpMode(Sleep_mode);  //设置睡眠模式0x01
 295   1              SX1276LoRaFsk(LORA_mode);             // 设置扩频模式,只能在睡眠模式下修改
 296   1              SX1276LoRaSetOpMode(Stdby_mode);   // 设置为普通模式
 297   1              SX1276WriteBuffer( REG_LR_DIOMAPPING1, GPIO_VARE_1);
 298   1              SX1276WriteBuffer( REG_LR_DIOMAPPING1, GPIO_VARE_1);
 299   1              SX1276WriteBuffer( REG_LR_DIOMAPPING2, GPIO_VARE_2);
C51 COMPILER V9.60.0.0   SX1278                                                            01/12/2024 22:11:18 PAGE 6   

 300   1              SX1276LoRaSetRFFrequency();
 301   1              SX1276LoRaSetRFPower(powerValue);
 302   1              SX1276LoRaSetSpreadingFactor(SpreadingFactor);   // 扩频因子设置
 303   1              SX1276LoRaSetErrorCoding(CodingRate);            //有效数据比
 304   1              SX1276LoRaSetPacketCrcOn(true);                   //CRC 校验打开
 305   1              SX1276LoRaSetSignalBandwidth(Bw_Frequency);      //设置扩频带宽
 306   1              SX1276LoRaSetImplicitHeaderOn(false);           //同步头是显性模式
 307   1              SX1276LoRaSetPayloadLength(0xff);//0x22 timeout中断
 308   1              SX1276LoRaSetSymbTimeout(0x3FF);
 309   1              SX1276LoRaSetMobileNode(true);                   // 低数据的优化
 310   1              RF_RECEIVE();
 311   1      //      uartSendString("\r\ninit finish\r\n");
 312   1      
 313   1      }
 314          
 315          /*
 316          function :if you want to send data,you can call it 
 317          RF_TRAN_P:data
 318          ASM_i:the length of the data
 319          */
 320          void  FUN_RF_SENDPACKET(unsigned char *RF_TRAN_P,
 321                          unsigned char LEN) {
 322   1              unsigned char ASM_i;
 323   1      //   lpTypefunc.paSwitchCmdfunc(txOpen);
 324   1              SX1276LoRaSetOpMode(Stdby_mode);
 325   1              SX1276WriteBuffer( REG_LR_HOPPERIOD, 0);        //不做频率跳变
 326   1              SX1276WriteBuffer(REG_LR_IRQFLAGSMASK, IRQN_TXD_Value); //打开发送中断
 327   1              SX1276WriteBuffer( REG_LR_PAYLOADLENGTH, LEN);   //最大数据包
 328   1              SX1276WriteBuffer( REG_LR_FIFOTXBASEADDR, 0);
 329   1              SX1276WriteBuffer( REG_LR_FIFOADDRPTR, 0);
 330   1              lpTypefunc.lpSwitchEnStatus(enOpen);
 331   1              lpTypefunc.lpByteWritefunc(0x80);
 332   1              for (ASM_i = 0; ASM_i < LEN; ASM_i++) {
 333   2                      lpTypefunc.lpByteWritefunc(*RF_TRAN_P);
 334   2                      RF_TRAN_P++;
 335   2              }
 336   1              lpTypefunc.lpSwitchEnStatus(enClose);
 337   1              SX1276WriteBuffer(REG_LR_DIOMAPPING1, 0x40);
 338   1              SX1276WriteBuffer(REG_LR_DIOMAPPING2, 0x00);
 339   1              SX1276LoRaSetOpMode(Transmitter_mode);
 340   1      }
 341          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1659    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     81    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
